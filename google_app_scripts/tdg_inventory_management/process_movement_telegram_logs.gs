/**
 * Resolves redirect URLs to get the final URL.
 * @param {string} url - The URL to resolve.
 * @return {string} The resolved URL or empty string on error.
 */
function resolveRedirect(url) {
  console.log("resolving " + url);
  try {
    let currentUrl = url;
    let redirectCount = 0;
    const maxRedirects = 10;

    while (redirectCount < maxRedirects) {
      const response = UrlFetchApp.fetch(currentUrl, {
        followRedirects: false,
        muteHttpExceptions: true
      });
      const responseCode = response.getResponseCode();
      Logger.log(responseCode);

      // If not a redirect (2xx or other), return the current URL
      if (responseCode < 300 || responseCode >= 400) {
        return currentUrl;
      }

      // Get the Location header for the redirect
      const headers = response.getHeaders();
      const location = headers['Location'] || headers['location'];
      console.log(location);
      if (!location) {
        Logger.log(`No Location header for redirect at ${currentUrl}`);
        return '';
      }

      // Update the current URL and increment redirect count
      currentUrl = location;
      redirectCount++;
      console.log("resolve count " + redirectCount);
    }

    Logger.log(`Exceeded maximum redirects (${maxRedirects}) for URL ${url}`);
    return '';
  } catch (e) {
    Logger.log(`Error resolving redirect for URL ${url}: ${e.message}`);
    return '';
  }
}

/**
 * Processes the inventory movement report string copied to the clipboard and returns a JSON object
 * with extracted sender name, recipient name, currency, amount, and source details.
 * The input string is expected to match the format generated by the Report Inventory Movement button:
 * "[INVENTORY MOVEMENT] manager name: <managerName>\nrecipient name: <recipientName>\ninventory item: <itemName>\nquantity: <quantity>"
 *
 * @param {string} reportText - The text copied to the clipboard from the Report Inventory Movement button.
 * @return {Object} JSON object containing extracted fields, source details, or an error message.
 */
function processInventoryReport(reportText) {
  // Constants for offchain assets
  const SPREADSHEET_ID = '1GE7PUq-UT6x2rBN-Q2ksogbWpgyuh2SaxJyG_uEK6PU';
  const SHEET_NAME = 'offchain asset location';
  const DEFAULT_AGL_SHEET_NAME = 'Balance'; // Default sheet name for AGL ledgers

  try {
    // Validate input
    if (!reportText || typeof reportText !== 'string') {
      return { error: 'Invalid or empty report text' };
    }

    // Expected format: [INVENTORY MOVEMENT] manager name: ... \nrecipient name: ... \ninventory item: ... \nquantity: ...
    const lines = reportText.split('\n').map(line => line.trim());
    
    // Check for correct header
    if (!lines[0].startsWith('[INVENTORY MOVEMENT]')) {
      return { error: 'Invalid report format: Missing [INVENTORY MOVEMENT] header' };
    }

    // Extract fields using regex for key-value pairs
    const managerMatch = lines.find(line => line.startsWith('manager name:'));
    const recipientMatch = lines.find(line => line.startsWith('recipient name:'));
    const itemMatch = lines.find(line => line.startsWith('inventory item:'));
    const quantityMatch = lines.find(line => line.startsWith('quantity:'));

    if (!managerMatch || !recipientMatch || !itemMatch || !quantityMatch) {
      return { error: 'Invalid report format: Missing required fields' };
    }

    // Extract values
    const managerName = managerMatch.replace('manager name:', '').trim();
    const recipientName = recipientMatch.replace('recipient name:', '').trim();
    const currency = itemMatch.replace('inventory item:', '').trim();
    const quantity = parseFloat(quantityMatch.replace('quantity:', '').trim());

    // Validate quantity
    if (isNaN(quantity) || quantity <= 0) {
      return { error: 'Invalid quantity: Must be a positive number' };
    }

    // Determine currency source (offchain or AGL ledger)
    let currencySource = {
      spreadsheet_id: '',
      sheet_name: '',
      ledger_name: '',
      ledger_url: ''
    };

    // Check if currency is from an AGL ledger (format: [AGL#] currency_name)
    const aglMatch = currency.match(/^\[(AGL\d+)\]\s*(.+)$/);
    if (aglMatch) {
      const ledgerName = aglMatch[1];
      // Resolve the ledger URL from https://www.agroverse.shop/[ledger_name]
      const agroverseUrl = `https://www.agroverse.shop/${ledgerName}`.toLowerCase();
      const resolvedUrl = resolveRedirect(agroverseUrl);
      currencySource = {
        spreadsheet_id: resolvedUrl.match(/\/d\/([^\/]+)/)?.[1] || '', // Extract spreadsheet ID from resolved URL
        sheet_name: DEFAULT_AGL_SHEET_NAME,
        ledger_name: ledgerName,
        ledger_url: resolvedUrl || 'Failed to resolve URL'
      };
    } else {
      // Assume currency is from offchain asset location
      currencySource = {
        spreadsheet_id: SPREADSHEET_ID,
        sheet_name: SHEET_NAME,
        ledger_name: 'offchain',
        ledger_url: `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/edit`
      };
    }

    // Return JSON object with extracted fields and source details
    return {
      sender_name: managerName,
      recipient_name: recipientName,
      currency: currency,
      amount: quantity,
      currency_source: currencySource
    };
  } catch (error) {
    Logger.log('Error processing inventory report: ' + error.message);
    return { error: 'Error processing report: ' + error.message };
  }
}

/**
 * Parses the "Telegram Chat Logs" sheet (Column G) for entries matching the [INVENTORY MOVEMENT] pattern,
 * processes them using processInventoryReport, and inserts new records into the "Inventory Movement" sheet.
 * Skips records already existing in "Inventory Movement" based on Telegram Update ID (Column A).
 * Maps columns as follows:
 * - Telegram Chat Logs Column A (Telegram Update ID) -> Inventory Movement Column A
 * - Telegram Chat Logs Column B (Telegram Chatroom ID) -> Inventory Movement Column B
 * - Telegram Chat Logs Column C (Telegram Chatroom Name) -> Inventory Movement Column C
 * - Telegram Chat Logs Column D (Telegram Message ID) -> Inventory Movement Column D
 * - Telegram Chat Logs Column E (Contributor Name) -> Inventory Movement Column E
 * - Telegram Chat Logs Column G (Contribution Made) -> Inventory Movement Column F
 * - Telegram Chat Logs Column L (Status Date) -> Inventory Movement Column G
 * - Inventory Movement Column H: sender_name extracted from Column G
 * - Inventory Movement Column I: recipient_name extracted from Column G
 * - Inventory Movement Column J: currency extracted from Column G, with [AGL#] prefix removed
 * - Inventory Movement Column K: amount extracted from Column G
 * - Inventory Movement Column L: ledger_name extracted from Column G
 * - Inventory Movement Column M: ledger_url extracted from Column G
 * - Inventory Movement Column N: "NEW"
 */
function processTelegramChatLogsToInventoryMovement() {
  const SPREADSHEET_ID = '1qbZZhf-_7xzmDTriaJVWj6OZshyQsFkdsAV8-pyzASQ';
  const TELEGRAM_SHEET_NAME = 'Telegram Chat Logs';
  const INVENTORY_SHEET_NAME = 'Inventory Movement';

  try {
    // Open the spreadsheet
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const telegramSheet = spreadsheet.getSheetByName(TELEGRAM_SHEET_NAME);
    const inventorySheet = spreadsheet.getSheetByName(INVENTORY_SHEET_NAME);

    if (!telegramSheet || !inventorySheet) {
      Logger.log(`Error: Sheet not found - Telegram Chat Logs: ${!!telegramSheet}, Inventory Movement: ${!!inventorySheet}`);
      return;
    }

    // Get existing Telegram Update IDs in Inventory Movement to avoid duplicates
    const inventoryLastRow = inventorySheet.getLastRow();
    const existingUpdateIds = inventoryLastRow > 0
      ? inventorySheet.getRange(1, 1, inventoryLastRow, 1).getValues().map(row => row[0])
      : [];

    // Get data from Telegram Chat Logs (starting from row 1, assuming no header)
    const telegramLastRow = telegramSheet.getLastRow();
    if (telegramLastRow < 1) {
      Logger.log('No data in Telegram Chat Logs');
      return;
    }
    // Read up to Column L (12th column) to include Status Date
    const telegramData = telegramSheet.getRange(1, 1, telegramLastRow, 12).getValues(); // Columns A to L

    // Prepare array to collect new rows for batch insertion
    const newRows = [];

    // Process each row in Telegram Chat Logs
    telegramData.forEach(row => {
      const updateId = row[0]; // Column A: Telegram Update ID
      const contribution = row[6]; // Column G: Contribution Made

      // Skip if updateId is empty or already exists in Inventory Movement
      if (!updateId || existingUpdateIds.includes(updateId)) {
        return;
      }

      // Check if Contribution Made matches [INVENTORY MOVEMENT] pattern
      if (typeof contribution === 'string' && contribution.trim().startsWith('[INVENTORY MOVEMENT]')) {
        const reportResult = processInventoryReport(contribution);
        if (reportResult.error) {
          Logger.log(`Error processing contribution for Update ID ${updateId}: ${reportResult.error}`);
          return;
        }

        // Map currency to original value by removing [AGL#] prefix
        const originalCurrency = reportResult.currency.replace(/^\[AGL\d+\]\s*/, '');

        // Create new row for Inventory Movement
        const newRow = [
          row[0], // Column A: Telegram Update ID
          row[1], // Column B: Telegram Chatroom ID
          row[2], // Column C: Telegram Chatroom Name
          row[3], // Column D: Telegram Message ID
          row[4], // Column E: Contributor Name
          row[6], // Column F: Contribution Made
          row[11], // Column G: Status Date
          reportResult.sender_name, // Column H: sender_name
          reportResult.recipient_name, // Column I: recipient_name
          originalCurrency, // Column J: currency (without [AGL#])
          reportResult.amount, // Column K: amount
          reportResult.currency_source.ledger_name, // Column L: ledger_name
          reportResult.currency_source.ledger_url, // Column M: ledger_url
          'NEW' // Column N: Status
        ];

        newRows.push(newRow);
      }
    });

    // Insert new rows into Inventory Movement sheet
    if (newRows.length > 0) {
      inventorySheet.getRange(inventoryLastRow + 1, 1, newRows.length, 14).setValues(newRows);
      Logger.log(`Inserted ${newRows.length} new records into Inventory Movement`);
    } else {
      Logger.log('No new valid inventory movement records found in Telegram Chat Logs');
    }
  } catch (error) {
    Logger.log(`Error in processTelegramChatLogsToInventoryMovement: ${error.message}`);
  }
}

/**
 * Test function to verify the processInventoryReport function.
 * @param {string} testReport - Optional test report string to process.
 */
function testProcessInventoryReport() {
  const testReport = "[INVENTORY MOVEMENT]\n" +
    "manager name: Gary Teh\n" +
    "recipient name: @alexadoglio\n" +
    "inventory item: [AGL6] Brazilian Reis\n" +
    "quantity: 1";
  const result = processInventoryReport(testReport);
  Logger.log(JSON.stringify(result, null, 2));

  // Test offchain asset
  const testReportOffchain = "[INVENTORY MOVEMENT]\n" +
    "manager name: Gary Teh\n" +
    "recipient name: @alexadoglio\n" +
    "inventory item: USD\n" +
    "quantity: 100";
  const resultOffchain = processInventoryReport(testReportOffchain);
  Logger.log(JSON.stringify(resultOffchain, null, 2));
}