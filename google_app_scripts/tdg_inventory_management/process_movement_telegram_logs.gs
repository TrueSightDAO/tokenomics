// Load API keys and configuration settings from Credentials.gs
setApiKeys();
const creds = getCredentials();

// Configuration Variables
const TELEGRAM_CHAT_ID = '-1002190388985'; // Fixed chat ID for Telegram notifications
const INVENTORY_SPREADSHEET_ID = '1qbZZhf-_7xzmDTriaJVWj6OZshyQsFkdsAV8-pyzASQ';
const OFFCHAIN_SPREADSHEET_ID = '1GE7PUq-UT6x2rBN-Q2ksogbWpgyuh2SaxJyG_uEK6PU';
const TELEGRAM_SHEET_NAME = 'Telegram Chat Logs';
const INVENTORY_SHEET_NAME = 'Inventory Movement';
const OFFCHAIN_SHEET_NAME = 'offchain transactions';
const AGL_SHEET_NAME = 'Balance';
const OFFCHAIN_ASSET_SHEET_NAME = 'offchain asset location';
const DEFAULT_AGL_SHEET_NAME = 'Balance'; // Default sheet name for AGL ledgers
const MAX_REDIRECTS = 10; // Maximum number of redirects to follow in resolveRedirect

/**
 * Resolves redirect URLs to get the final URL.
 * @param {string} url - The URL to resolve.
 * @return {string} The resolved URL or empty string on error.
 */
function resolveRedirect(url) {
  console.log("resolving " + url);
  try {
    let currentUrl = url;
    let redirectCount = 0;

    while (redirectCount < MAX_REDIRECTS) {
      const response = UrlFetchApp.fetch(currentUrl, {
        followRedirects: false,
        muteHttpExceptions: true
      });
      const responseCode = response.getResponseCode();
      Logger.log(responseCode);

      // If not a redirect (2xx or other), return the current URL
      if (responseCode < 300 || responseCode >= 400) {
        return currentUrl;
      }

      // Get the Location header for the redirect
      const headers = response.getHeaders();
      const location = headers['Location'] || headers['location'];
      console.log(location);
      if (!location) {
        Logger.log(`No Location header for redirect at ${currentUrl}`);
        return '';
      }

      // Update the current URL and increment redirect count
      currentUrl = location;
      redirectCount++;
      console.log("resolve count " + redirectCount);
    }

    Logger.log(`Exceeded maximum redirects (${MAX_REDIRECTS}) for URL ${url}`);
    return '';
  } catch (e) {
    Logger.log(`Error resolving redirect for URL ${url}: ${e.message}`);
    return '';
  }
}

/**
 * Processes the inventory movement report string copied to the clipboard and returns a JSON object
 * with extracted sender name, recipient name, currency, amount, and source details.
 * The input string is expected to match the format generated by the Report Inventory Movement button:
 * "[INVENTORY MOVEMENT] manager name: <managerName>\nrecipient name: <recipientName>\ninventory item: <itemName>\nquantity: <quantity>"
 *
 * @param {string} reportText - The text copied to the clipboard from the Report Inventory Movement button.
 * @return {Object} JSON object containing extracted fields, source details, or an error message.
 */
function processInventoryReport(reportText) {
  try {
    // Validate input
    if (!reportText || typeof reportText !== 'string') {
      return { error: 'Invalid or empty report text' };
    }

    // Expected format: [INVENTORY MOVEMENT] manager name: ... \nrecipient name: ... \ninventory item: ... \nquantity: ...
    const lines = reportText.split('\n').map(line => line.trim());
    
    // Check for correct header
    if (!lines[0].startsWith('[INVENTORY MOVEMENT]')) {
      return { error: 'Invalid report format: Missing [INVENTORY MOVEMENT] header' };
    }

    // Extract fields using regex for key-value pairs
    const managerMatch = lines.find(line => line.startsWith('manager name:'));
    const recipientMatch = lines.find(line => line.startsWith('recipient name:'));
    const itemMatch = lines.find(line => line.startsWith('inventory item:'));
    const quantityMatch = lines.find(line => line.startsWith('quantity:'));

    if (!managerMatch || !recipientMatch || !itemMatch || !quantityMatch) {
      return { error: 'Invalid report format: Missing required fields' };
    }

    // Extract values
    const managerName = managerMatch.replace('manager name:', '').trim();
    const recipientName = recipientMatch.replace('recipient name:', '').trim();
    const currency = itemMatch.replace('inventory item:', '').trim();
    const quantity = parseFloat(quantityMatch.replace('quantity:', '').trim());

    // Validate quantity
    if (isNaN(quantity) || quantity <= 0) {
      return { error: 'Invalid quantity: Must be a positive number' };
    }

    // Determine currency source (offchain or AGL ledger)
    let currencySource = {
      spreadsheet_id: '',
      sheet_name: '',
      ledger_name: '',
      ledger_url: ''
    };

    // Check if currency is from an AGL ledger (format: [AGL#] currency_name)
    const aglMatch = currency.match(/^\[(AGL\d+)\]\s*(.+)$/);
    if (aglMatch) {
      const ledgerName = aglMatch[1];
      // Resolve the ledger URL from https://www.agroverse.shop/[ledger_name]
      const agroverseUrl = `https://www.agroverse.shop/${ledgerName}`.toLowerCase();
      const resolvedUrl = resolveRedirect(agroverseUrl);
      currencySource = {
        spreadsheet_id: resolvedUrl.match(/\/d\/([^\/]+)/)?.[1] || '', // Extract spreadsheet ID from resolved URL
        sheet_name: DEFAULT_AGL_SHEET_NAME,
        ledger_name: ledgerName,
        ledger_url: resolvedUrl || 'Failed to resolve URL'
      };
    } else {
      // Assume currency is from offchain asset location
      currencySource = {
        spreadsheet_id: OFFCHAIN_SPREADSHEET_ID,
        sheet_name: OFFCHAIN_ASSET_SHEET_NAME,
        ledger_name: 'offchain',
        ledger_url: `https://docs.google.com/spreadsheets/d/${OFFCHAIN_SPREADSHEET_ID}/edit`
      };
    }

    // Return JSON object with extracted fields and source details
    return {
      sender_name: managerName,
      recipient_name: recipientName,
      currency: currency,
      amount: quantity,
      currency_source: currencySource
    };
  } catch (error) {
    Logger.log('Error processing inventory report: ' + error.message);
    return { error: 'Error processing report: ' + error.message };
  }
}

/**
 * Parses the "Telegram Chat Logs" sheet (Column G) for entries matching the [INVENTORY MOVEMENT] pattern,
 * processes them using processInventoryReport, and inserts new records into the "Inventory Movement" sheet.
 * Skips records already existing in "Inventory Movement" based on Telegram Update ID (Column A).
 * Maps columns as follows:
 * - Telegram Chat Logs Column A (Telegram Update ID) -> Inventory Movement Column A
 * - Telegram Chat Logs Column B (Telegram Chatroom ID) -> Inventory Movement Column B
 * - Telegram Chat Logs Column C (Telegram Chatroom Name) -> Inventory Movement Column C
 * - Telegram Chat Logs Column D (Telegram Message ID) -> Inventory Movement Column D
 * - Telegram Chat Logs Column E (Contributor Name) -> Inventory Movement Column E
 * - Telegram Chat Logs Column G (Contribution Made) -> Inventory Movement Column F
 * - Telegram Chat Logs Column L (Status Date) -> Inventory Movement Column G
 * - Inventory Movement Column H: sender_name extracted from Column G
 * - Inventory Movement Column I: recipient_name extracted from Column G
 * - Inventory Movement Column J: currency extracted from Column G, with [AGL#] prefix removed
 * - Inventory Movement Column K: amount extracted from Column G
 * - Inventory Movement Column L: ledger_name extracted from Column G
 * - Inventory Movement Column M: ledger_url extracted from Column G
 * - Inventory Movement Column N: "NEW"
 */
function processTelegramChatLogsToInventoryMovement() {
  try {
    // Open the spreadsheet
    const spreadsheet = SpreadsheetApp.openById(INVENTORY_SPREADSHEET_ID);
    const telegramSheet = spreadsheet.getSheetByName(TELEGRAM_SHEET_NAME);
    const inventorySheet = spreadsheet.getSheetByName(INVENTORY_SHEET_NAME);

    if (!telegramSheet || !inventorySheet) {
      Logger.log(`Error: Sheet not found - Telegram Chat Logs: ${!!telegramSheet}, Inventory Movement: ${!!inventorySheet}`);
      return;
    }

    // Get existing Telegram Update IDs in Inventory Movement to avoid duplicates
    const inventoryLastRow = inventorySheet.getLastRow();
    const existingUpdateIds = inventoryLastRow > 0
      ? inventorySheet.getRange(1, 1, inventoryLastRow, 1).getValues().map(row => row[0])
      : [];

    // Get data from Telegram Chat Logs (starting from row 1, assuming no header)
    const telegramLastRow = telegramSheet.getLastRow();
    if (telegramLastRow < 1) {
      Logger.log('No data in Telegram Chat Logs');
      return;
    }
    // Read up to Column L (12th column) to include Status Date
    const telegramData = telegramSheet.getRange(1, 1, telegramLastRow, 12).getValues(); // Columns A to L

    // Prepare array to collect new rows for batch insertion
    const newRows = [];

    // Process each row in Telegram Chat Logs
    telegramData.forEach(row => {
      const updateId = row[0]; // Column A: Telegram Update ID
      const contribution = row[6]; // Column G: Contribution Made

      // Skip if updateId is empty or already exists in Inventory Movement
      if (!updateId || existingUpdateIds.includes(updateId)) {
        return;
      }

      // Check if Contribution Made matches [INVENTORY MOVEMENT] pattern
      if (typeof contribution === 'string' && contribution.trim().startsWith('[INVENTORY MOVEMENT]')) {
        const reportResult = processInventoryReport(contribution);
        if (reportResult.error) {
          Logger.log(`Error processing contribution for Update ID ${updateId}: ${reportResult.error}`);
          return;
        }

        // Map currency to original value by removing [AGL#] prefix
        const originalCurrency = reportResult.currency.replace(/^\[AGL\d+\]\s*/, '');

        // Create new row for Inventory Movement
        const newRow = [
          row[0], // Column A: Telegram Update ID
          row[1], // Column B: Telegram Chatroom ID
          row[2], // Column C: Telegram Chatroom Name
          row[3], // Column D: Telegram Message ID
          row[4], // Column E: Contributor Name
          row[6], // Column F: Contribution Made
          row[11], // Column G: Status Date
          reportResult.sender_name, // Column H: sender_name
          reportResult.recipient_name, // Column I: recipient_name
          originalCurrency, // Column J: currency (without [AGL#])
          reportResult.amount, // Column K: amount
          reportResult.currency_source.ledger_name, // Column L: ledger_name
          reportResult.currency_source.ledger_url, // Column M: ledger_url
          'NEW' // Column N: Status
        ];

        newRows.push(newRow);
      }
    });

    // Insert new rows into Inventory Movement sheet
    if (newRows.length > 0) {
      inventorySheet.getRange(inventoryLastRow + 1, 1, newRows.length, 14).setValues(newRows);
      Logger.log(`Inserted ${newRows.length} new records into Inventory Movement`);
    } else {
      Logger.log('No new valid inventory movement records found in Telegram Chat Logs');
    }
  } catch (error) {
    Logger.log(`Error in processTelegramChatLogsToInventoryMovement: ${error.message}`);
  }
}

/**
 * Sends a Telegram notification to the specified chat ID with transaction details.
 * @param {string} contributionMade - The Contribution Made field from Inventory Movement Column F.
 * @param {string} ledgerName - The ledger name (e.g., AGL6 or offchain).
 * @param {string} ledgerUrl - The ledger URL from Inventory Movement Column M.
 */
function sendInventoryTransactionNotification(contributionMade, ledgerName, ledgerUrl) {
  const token = creds.TELEGRAM_API_TOKEN;
  if (!token) {
    Logger.log(`sendInventoryTransactionNotification: Error: TELEGRAM_API_TOKEN not set in Credentials`);
    return;
  }

  const apiUrl = `https://api.telegram.org/bot${token}/sendMessage`;

  // Format the notification message with details from contributionMade
  const messageText = `âœ… Transaction successfully updated on ${ledgerName} ledger.\n\nDetails:\n${contributionMade}\n\nReview here: ${ledgerUrl}`;

  const payload = {
    chat_id: TELEGRAM_CHAT_ID,
    text: messageText
  };

  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    Logger.log(`sendInventoryTransactionNotification: Sending notification for transaction on ${ledgerName} to chat ${TELEGRAM_CHAT_ID}`);
    const response = UrlFetchApp.fetch(apiUrl, options);
    const status = response.getResponseCode();
    const responseText = response.getContentText();
    if (status === 200) {
      Logger.log(`sendInventoryTransactionNotification: Successfully sent notification for transaction on ${ledgerName} to chat ${TELEGRAM_CHAT_ID}`);
    } else {
      Logger.log(`sendInventoryTransactionNotification: Failed to send notification for ${ledgerName}. Status: ${status}, Response: ${responseText}`);
    }
  } catch (e) {
    Logger.log(`sendInventoryTransactionNotification: Error sending Telegram notification for ${ledgerName}: ${e.message}`);
  }
}

/**
 * Parses the "Inventory Movement" sheet for records with status "NEW" in Column N and inserts double-entry
 * records into the respective ledgers (AGL or offchain). Updates Column O with the row numbers of the
 * inserted records, sets Column N to "PROCESSED", and sends a Telegram notification with transaction details.
 * For AGL ledgers, inserts into the "Balance" sheet of the spreadsheet from Column M (ledger_url).
 * For offchain ledgers, inserts into the "offchain transactions" sheet of the offchain SPREADSHEET_ID.
 * Double-entry mappings:
 * Part 1 (Sender/Debit):
 * - Column A: Status Date (Inventory Movement Column G)
 * - Column B: Contribution Made (Inventory Movement Column F)
 * - Column C: Sender Name (Inventory Movement Column H)
 * - Column D: Amount * -1 (Inventory Movement Column K)
 * - Column E: Currency (Inventory Movement Column J)
 * - Column F: "Assets" (for AGL ledgers only)
 * Part 2 (Recipient/Credit):
 * - Column A: Status Date (Inventory Movement Column G)
 * - Column B: Contribution Made (Inventory Movement Column F)
 * - Column C: Recipient Name (Inventory Movement Column I)
 * - Column D: Amount (Inventory Movement Column K)
 * - Column E: Currency (Inventory Movement Column J)
 * - Column F: "Assets" (for AGL ledgers only)
 */
function processInventoryMovementToLedgers() {
  try {
    // Open the Inventory Movement spreadsheet
    const inventorySpreadsheet = SpreadsheetApp.openById(INVENTORY_SPREADSHEET_ID);
    const inventorySheet = inventorySpreadsheet.getSheetByName(INVENTORY_SHEET_NAME);

    if (!inventorySheet) {
      Logger.log(`Error: Inventory Movement sheet not found`);
      return;
    }

    // Get all data from Inventory Movement (Columns A to N)
    const inventoryLastRow = inventorySheet.getLastRow();
    if (inventoryLastRow < 1) {
      Logger.log('No data in Inventory Movement');
      return;
    }
    const inventoryData = inventorySheet.getRange(1, 1, inventoryLastRow, 14).getValues(); // Columns A to N

    // Process each row in Inventory Movement
    const updates = []; // Store updates for Column N (status) and Column O (row numbers)
    inventoryData.forEach((row, index) => {
      const rowNumber = index + 1;
      const status = row[13]; // Column N: Status
      if (status !== 'NEW') {
        return; // Skip if status is not NEW
      }

      const ledgerName = row[11]; // Column L: ledger_name
      const ledgerUrl = row[12]; // Column M: ledger_url
      const statusDate = row[6]; // Column G: Status Date
      const contributionMade = row[5]; // Column F: Contribution Made
      const senderName = row[7]; // Column H: sender_name
      const recipientName = row[8]; // Column I: recipient_name
      const currency = row[9]; // Column J: currency (without [AGL#])
      const amount = row[10]; // Column K: amount

      // Validate required fields
      if (!statusDate || !contributionMade || !senderName || !recipientName || !currency || !amount) {
        Logger.log(`Skipping row ${rowNumber}: Missing required fields`);
        return;
      }

      let targetSpreadsheetId, targetSheetName;
      if (ledgerName === 'offchain') {
        targetSpreadsheetId = OFFCHAIN_SPREADSHEET_ID;
        targetSheetName = OFFCHAIN_SHEET_NAME;
      } else {
        // For AGL ledgers, extract spreadsheet ID from ledger_url
        targetSpreadsheetId = ledgerUrl.match(/\/d\/([^\/]+)/)?.[1] || '';
        targetSheetName = AGL_SHEET_NAME;
      }

      if (!targetSpreadsheetId) {
        Logger.log(`Skipping row ${rowNumber}: Invalid ledger URL for ${ledgerName}`);
        return;
      }

      // Open the target ledger spreadsheet
      let targetSheet;
      try {
        const targetSpreadsheet = SpreadsheetApp.openById(targetSpreadsheetId);
        targetSheet = targetSpreadsheet.getSheetByName(targetSheetName);
        if (!targetSheet) {
          Logger.log(`Error: Sheet ${targetSheetName} not found in spreadsheet ${targetSpreadsheetId} for row ${rowNumber}`);
          return;
        }
      } catch (e) {
        Logger.log(`Error accessing spreadsheet ${targetSpreadsheetId} for row ${rowNumber}: ${e.message}`);
        return;
      }

      // Get the last row of the target sheet
      const targetLastRow = targetSheet.getLastRow();

      // Prepare double-entry records
      const doubleEntryRows = [
        // Part 1: Sender (Debit)
        [
          statusDate, // Column A: Status Date
          contributionMade, // Column B: Contribution Made
          senderName, // Column C: Sender Name
          -amount, // Column D: Amount * -1
          currency, // Column E: Currency
          ledgerName === 'offchain' ? '' : 'Assets' // Column F: "Assets" for AGL, empty for offchain
        ],
        // Part 2: Recipient (Credit)
        [
          statusDate, // Column A: Status Date
          contributionMade, // Column B: Contribution Made
          recipientName, // Column C: Recipient Name
          amount, // Column D: Amount
          currency, // Column E: Currency
          ledgerName === 'offchain' ? '' : 'Assets' // Column F: "Assets" for AGL, empty for offchain
        ]
      ];

      // Insert double-entry records
      try {
        targetSheet.getRange(targetLastRow + 1, 1, 2, 6).setValues(doubleEntryRows);
        // Record the row numbers (1-based) of the inserted records
        const insertedRowNumbers = `${targetLastRow + 1},${targetLastRow + 2}`;
        updates.push({ rowNumber, insertedRowNumbers });
        Logger.log(`Inserted double-entry records for row ${rowNumber} in ${targetSheetName} (rows ${insertedRowNumbers})`);

        // Send Telegram notification
        sendInventoryTransactionNotification(contributionMade, ledgerName, ledgerUrl);
      } catch (e) {
        Logger.log(`Error inserting double-entry records for row ${rowNumber} in ${targetSheetName}: ${e.message}`);
        return;
      }
    });

    // Update Inventory Movement with row numbers and status
    updates.forEach(update => {
      inventorySheet.getRange(update.rowNumber, 15).setValue(update.insertedRowNumbers); // Column O
      inventorySheet.getRange(update.rowNumber, 14).setValue('PROCESSED'); // Column N
    });

    if (updates.length > 0) {
      Logger.log(`Processed ${updates.length} records in Inventory Movement`);
    } else {
      Logger.log('No new records with status NEW found in Inventory Movement');
    }
  } catch (error) {
    Logger.log(`Error in processInventoryMovementToLedgers: ${error.message}`);
  }
}

/**
 * Test function to verify the processInventoryReport function.
 * @param {string} testReport - Optional test report string to process.
 */
function testProcessInventoryReport() {
  const testReport = "[INVENTORY MOVEMENT]\n" +
    "manager name: Gary Teh\n" +
    "recipient name: @alexadoglio\n" +
    "inventory item: [AGL6] Brazilian Reis\n" +
    "quantity: 1";
  const result = processInventoryReport(testReport);
  Logger.log(JSON.stringify(result, null, 2));

  // Test offchain asset
  const testReportOffchain = "[INVENTORY MOVEMENT]\n" +
    "manager name: Gary Teh\n" +
    "recipient name: @alexadoglio\n" +
    "inventory item: USD\n" +
    "quantity: 100";
  const resultOffchain = processInventoryReport(testReportOffchain);
  Logger.log(JSON.stringify(resultOffchain, null, 2));
}

/**
 * Runs both processTelegramChatLogsToInventoryMovement and processInventoryMovementToLedgers sequentially.
 */
function processTelegramChatLogs() {
  processTelegramChatLogsToInventoryMovement();
  processInventoryMovementToLedgers();
}